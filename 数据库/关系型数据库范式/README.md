# 关系型数据库范式

范式越高，性能越差。

因为范式越高，就越需要连接多个表才能得到所需要的数据，所以在设计的时候还要结合具体的情况和场景，在一般的项目中，使用到第三范式也就足够了，性能好而且也方便管理数据。

## 第一范式

单一原子性，不可再分。

### 样例

| f_student_id | f_card_id | f_name | f_class      | f_card |
| ------------ | --------- | ------ | ------------ | ------ |
| 1            | 1         | 小明   | 一年级，1 班 | 100.00 |

### 分析

`f_class` 还可以再分。

### 优化

| f_student_id | f_card_id | f_name | f_grade | f_class | f_card |
| ------------ | --------- | ------ | ------- | ------- | ------ |
| 1            | 1         | 小明   | 一年级  | 1 班    | 100.00 |

## 第二范式

在第一范式基础上，消除部分函数依赖（只存在完全函数依赖）。

### 样例

| f_student_id | f_card_id | f_name | f_grade | f_class | f_card |
| ------------ | --------- | ------ | ------- | ------- | ------ |
| 1            | 1         | 小明   | 一年级  | 1 班    | 100.00 |

### 分析

一张表里存在多个依赖，`f_name`、`f_grade`、`f_class` 依赖于 `f_student_id`，`f_card` 依赖于 `f_card_id`。

### 优化

| f_student_id | f_card_id | f_card |
| ------------ | --------- | ------ |
| 1            | 1         | 100.00 |

| f_student_id | f_name | f_grade | f_class |
| ------------ | ------ | ------- | ------- |
| 1            | 小明   | 一年级  | 1 班    |

## 第三范式

在第二范式基础上，消除传递函数依赖。

### 样例

| f_student_id | f_card_id | f_card |
| ------------ | --------- | ------ |
| 1            | 1         | 100.00 |

| f_student_id | f_name | f_grade | f_class |
| ------------ | ------ | ------- | ------- |
| 1            | 小明   | 一年级  | 1 班    |

### 分析

`f_card` 依赖于 `f_card_id`，而 `f_card_id` 又依赖于 `f_student_id`。

### 优化

| f_student_id | f_card_id |
| ------------ | --------- |
| 1            | 1         |

| f_student_id | f_name | f_grade | f_class |
| ------------ | ------ | ------- | ------- |
| 1            | 小明   | 一年级  | 1 班    |

| f_card_id | f_card |
| --------- | ------ |
| 1         | 100.00 |
